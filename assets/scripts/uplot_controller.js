"use strict";function UPLOT_MAKER(t,a,e){return new uPlot(t,a,e)}var uPlot_Controller;!function(t){function a(t){let a=0,e=0,r=0,n=0,s=0;if(/^\d+-\d+:\d+$/.test(t)){const n=t.match(/^(\d+)-(\d+):(\d+)$/);n&&(a=parseInt(n[1],10),e=parseInt(n[2],10),r=parseInt(n[3],10))}else if(/^\d+:\d+:\d+$/.test(t)){const a=t.match(/^(\d+):(\d+):(\d+)$/);a&&(e=parseInt(a[1],10),r=parseInt(a[2],10),n=parseInt(a[3],10))}else if(/^\d+:\d+$/.test(t)){const a=t.match(/^(\d+):(\d+)$/);a&&(r=parseInt(a[1],10),n=parseInt(a[2],10))}else if(/^\d+\.\d+s$/.test(t)){const a=t.match(/^(\d+)\.(\d+)s$/);a&&(n=parseInt(a[1],10),s=parseInt(a[2].padEnd(3,"0").substring(0,3),10))}else if(/^\d+ms$/.test(t)){const a=t.match(/^(\d+)ms$/);a&&(s=parseInt(a[1],10))}return s+1e3*n+60*r*1e3+60*e*60*1e3+24*a*60*60*1e3}function e(t,a){const e=Math.floor(t/1e3),r=t%1e3,n=e%60,s=Math.floor(e/60%60),o=Math.floor(e/3600%24),i=Math.floor(e/86400);switch(a){case"ms":default:return`${t}ms`;case"s.ms":return`${e}.${r.toString().padStart(3,"0")}s`;case"m:s":return`${s}:${n.toString().padStart(2,"0")}`;case"h:m:s":return`${o}:${s.toString().padStart(2,"0")}:${n.toString().padStart(2,"0")}`;case"d-h:m":return`${i}-${o.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`}}function r(a,r){g=a,y=r,u=r.clientWidth,f=r.clientHeight,h();const n="log"===g.chart.y.type&&g.chart.y.base,s=g.chart.y.type.split("-")[0],o="linear-manual"===g.chart.y.type,i={x:{type:"linear",time:!1},y:{type:s}};if(n&&(i.y.distr=3,i.y.log=n),o){const t=g.chart.y;i.y.min=t.min,i.y.max=t.max}const l="time"===g.chart.x.type,c=[{label:g.chart.x.title},{label:g.chart.y.title}];l&&(c[0].values=(t,a)=>a.map(t=>e(t,g.chart.x.format)));const d=[{label:g.chart.x.title}];for(let t=0;t<g.datasets.length;t++){const a=g.datasets[t],[e,r,n]=a.color.match(/\w\w/g).map(t=>parseInt(t,16)),s=`rgba(${e}, ${r}, ${n}, 0.1)`;d.push({label:a.label,stroke:a.color,fill:g.chart.options.fill?s:null,points:{show:g.chart.options.points,size:5,stroke:a.color,fill:s}})}const p={title:g.chart.title,width:u,height:f,scales:i,axes:c,series:d,pixelRatio:window.devicePixelRatio||1};t.length="linear"===g.chart.x.type?g.chart.x.max-g.chart.x.min:g.chart.x.max;try{t.chart=UPLOT_MAKER(p,t.data,y)}catch(t){throw new Error(`Failed to create uPlot chart: ${t}`)}}function n(a){if(!t.chart)throw new Error("Chart not initialized. Call init() first.");if(t.data=a,t.chart.setData(a),"linear-manual"===g.chart.y.type){const a=g.chart.y;t.chart.setScale("y",{min:a.min,max:a.max})}}function s(){if(!t.chart||!y)throw new Error("Chart not initialized. Call init() first.");u=y.clientWidth,f=y.clientHeight}function o(){t.chart&&(t.chart.destroy(),t.chart=null),t.data=[],g=null,y=null}function i(){return null!==t.chart&&void 0!==t.chart}function l(a,e){if(a===g.serial.mcu_commands.cls)h();else{t.data.forEach(a=>{t.length===a.length&&a.shift()});const r=a.split(g.serial.break);"time"===g.chart.x.type&&(g.chart.x.manual&&(e=parseInt(r[0]),r.shift()),t.data[0].push(e)),r.forEach((a,e)=>{const r=parseFloat(a);isNaN(r)?t.data[e+1].push(NaN):t.data[e+1].push(r)})}}function c(){n(t.data)}function h(){if(t.data=[],"linear"===g.chart.x.type){const a=g.chart.x;t.data.push(Array.from({length:a.max-a.min+1},(t,e)=>a.min+e))}else t.data.push([]);g.datasets.forEach(()=>{t.data.push([])})}function d(){function a(t,a){const e=Math.floor(t/1e3),r=t%1e3,n=e%60,s=Math.floor(e/60%60),o=Math.floor(e/3600%24),i=Math.floor(e/86400);switch(a){case"ms":default:return`${t}ms`;case"s.ms":return`${e}.${r.toString().padStart(3,"0")}s`;case"m:s":return`${s}:${n.toString().padStart(2,"0")}`;case"h:m:s":return`${o}:${s.toString().padStart(2,"0")}:${n.toString().padStart(2,"0")}`;case"d-h:m":return`${i}-${o.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`}}const e=g.chart.title,r=t.data[0]||[],n=Math.min(...r),s=Math.max(...r),o=s-n,i={raw:[...r],formatted:"time"===g.chart.x.type?r.map(t=>a(t,g.chart.x.format)):r.map(t=>t.toString()),min:n,max:s,range:o},l=[];t.data.slice(1).forEach(t=>{t.forEach(t=>{isNaN(t)||l.push(t)})});const c=g.chart.y.type.split("-")[0],h="log"===g.chart.y.type?g.chart.y.base:null,d=l.length>0?Math.min(...l):0,p=l.length>0?Math.max(...l):0,m=null===h?d:Math.pow(h,Math.floor(Math.log(d)/Math.log(h))),u=null===h?p:Math.pow(h,Math.ceil(Math.log(p)/Math.log(h))),f=u-m,y=g.datasets.map((a,e)=>({label:a.label,color:a.color,data:t.data[e+1]||[]}));return{title:e,grid:{x:{title:g.chart.x.title,type:g.chart.x.type,ticks:i,time_format:"time"===g.chart.x.type?g.chart.x.format:null},y:{title:g.chart.y.title,type:c,ticks:{min:m,max:u,range:f},base:h}},series:y}}function p(){const a=t.data[0],r=t.data.slice(1),n=a.length;let s=[x(g.chart.x.type)];g.datasets.forEach(t=>{s.push(t.label)});let o=s.join(",")+"\n";for(let t=0;t<n;t++){let n=("linear"===g.chart.x.type?a[t]:e(a[t],g.chart.x.format))+","+r.map(a=>void 0!==a[t]?a[t]:"").join(",");o+=n+"\n"}return o}function m(t){try{const e=t.trim().split("\n").map(t=>t.split(",").map(t=>t.trim()));if(e.length<2)throw new Error("CSV must contain at least a header row and one data row");const r=e[0];x(g.chart.x.type);r[0];const n=1+g.datasets.length;if(r.length!==n)throw new Error(`CSV has ${r.length} columns but expected ${n} (1 for X-axis + ${g.datasets.length} datasets)`);h();const s=Date.now();for(let t=1;t<e.length;t++){const n=e[t];if(n.length!==r.length)continue;let o,i;if("time"===g.chart.x.type){g.chart.x.manual?(o=a(n[0]),i=o.toString()+g.serial.break+n.slice(1).join(g.serial.break)):(o=Date.now()-s,i=n.slice(1).join(g.serial.break))}else o=Date.now()-s,i=n.slice(1).join(g.serial.break);l(i,o)}}catch(t){throw new Error(`Failed to import CSV: ${t instanceof Error?t.message:String(t)}`)}}let u,f,g,y;t.data=[];const x=t=>t.charAt(0).toUpperCase()+t.slice(1);t.init=r,t.update=n,t.resize=s,t.destroy=o,t.isInitialized=i,t.push=l,t.refresh=c,t.clear=h,t.export_json=d,t.export_csv=p,t.import_csv=m}(uPlot_Controller||(uPlot_Controller={}));